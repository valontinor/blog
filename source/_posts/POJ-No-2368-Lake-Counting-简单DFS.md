---
title: POJ No.2368 Lake Counting 简单DFS
date: 2016-03-29 00:04:50
tags: DFS
categories: 算法
---
#### 深度优先（DFS，Depth-First Search）
***
深度优先搜索是搜索的方法之一，它是从某个状态（节点）开始，不断的转移状态（节点）直到无法转移为止，然后再回退到前一步的状态（节点），继续转移到其它的状态（节点），不断重复，直到找到所搜索的状态（节点）或遍历完所有的状态（节点）为止。
***
#### 问题描述
> 有一个大小为N*M的园子，后来积起了水。八连通的积水被认为是连接在一起    的。请求出园子里共有多少水洼？（八连通指的是下图中相对W的\*部分）  
> \*  \*  \*   
> \* w  \*  
> \*  \*  \*
> w表示积水，\*表示和其连通的区域  
> 限制条件：N，M <= 100
<!--more-->
#### 输入
***
N = 10，M = 12
园子如下图（'w'表示积水，'.'表示没有积水）  
W........WW.  
.WWW.....WWW  
....WW...WW.  
.........WW.  
.........W..  
..W......W..  
.W.W.....WW.  
W.W.W.....W.  
.W.W......W.  
..W.......W.   

#### 输出
***
3  
#### 问题分析
***
要求出园子里有总共有多少水洼，其实就是求出园子有多少个相互独立的w“块”，这些w“块”之间相互独立，彼此之间的w不能八连通。而w“块”里面的w则是彼此八连通在一起的，从而形成一个水洼。要算出水洼的数目，可以从任意的w开始，DFS其八连通的方位的w，将所有的w都替换为‘.’，这样一次DFS后，所有与初始w八连通的所有w都被替换成了‘.’。对整个园子进行遍历，如果有位置出现w，则对其进行DFS，总共进行DFS的次数就是答案了。8个方向共对应了8种状态转移，每个格子作为DFS的参数，至多被调用一次，所以算法的复杂度为：O(8\*N\*M)。
#### 算法代码（C++）
***
```
//输入  
int N, M;  
char field[MAX_N][MAX_M + 1];  

//当前位置(x,y)  
void dfs(int x, int y) {  
	//将当前为止替换为.  
	field[x][y] = '.'  
	
	for(int dx = -1; dx < = 1; dx++) {
		for(int dy = -1; dy <= 1; dy++) {
			int nx = x + dx;
			int ny = y + dy;
			if (0 <= dx && nx < N && 0 <= dy && dy < M && field[nx][ny] == 'w')
				dfs(nx, ny);
	
	return ;
	
	void solve() {
		int result = 0;
		for(int i = 0; i < N; i++) {
			for(int j = 0; j < M; j++) {
				if (field[i][j] == 'w')
					des(i, j);
					result ++;
			}
		}
	}
	printf("%d\n", result);
		
```
